---
title: "[유데미x스나이퍼팩토리] 프로젝트 캠프 : Next.js 3기 - JS의 배경과 트랜스컴파일러"
description: "어떻게 글을 작성하고 추가할까요?"
date: 2024-09-29
update: 2024-09-29
tags:
  - 스나이퍼팩토리
series: "프로젝트 캠프"
---

![](./nextjs_1.png)

<br>

# JS의 배경과 트랜스컴파일러

### 자바스크립트 히스토리

1990년 - 월드 와이드 웹의 탄생

```
• 팀 버너스리(Tim Berners-Lee)는 1990년 월드 와이드 웹(WWW)을 개발해 인터넷 상의 정보 접근 방식을 크게 변화시켰다.
• 당시 웹은 단순한 정적 웹 페이지로 구성되었고, 사용자와 상호작용하는 방식이 매우 제한적이었다.
```

1994년 - 넷스케이프의 등장

```
• 넷스케이프 커뮤니케이션즈(Netscape Communications)가 창립되었고, 웹 브라우저인 Netscape Navigator가 출시된다.
• 당시 웹은 빠르게 성장하고 있었고, 동적인 웹 페이지와 사용자 상호작용에 대한 요구가 증가했다.
```

1995년 - 자바스크립트의 탄생

```
• 브렌던 아이크(Brendan Eich)가 넷스케이프에 합류하면서 자바스크립트를 개발했다.
• 원래 이 언어는 Mocha라는 이름이었으며, 이후 LiveScript로 바뀌었으나, 당시 인기가 많던 프로그래밍 언어 Java의 이름을 빌려 JavaScript로 명명되었다.
• 이 언어는 10일 만에 개발되었으며, 웹 브라우저 내에서 간단한 동작과 상호작용을 가능하게 하는 스크립트 언어로 설계되었다.
```

1996년 - 마이크로소프트의 대응과 JScript

```
• 마이크로소프트는 자바스크립트의 인기를 인식하고, 자사의 인터넷 익스플로러(Internet Explorer) 브라우저에 호환되는 JScript를 출시했다.
• 이는 자바스크립트와 거의 동일하지만 이름만 다르게 붙인 것이었다.
• 브라우저 간 호환성 문제가 생기기 시작했고, 자바스크립트의 표준화 필요성이 대두되었다.
```

1997년 - ECMAScript 표준화

```
• 자바스크립트를 표준화하기 위해 ECMA(유럽 정보통신 표준화 기구)에서 작업을 시작했고, 이 결과물이 ECMAScript 1(ES1)이다.
• ECMAScript는 자바스크립트의 표준 사양이 되었고, 이를 통해 여러 브라우저에서 자바스크립트의 호환성이 유지될 수 있게 되었다.
```

1999년 - ECMAScript 3 (ES3)

```
• ECMAScript 3은 자바스크립트에 대한 중요한 업그레이드였다.
• 정규 표현식(Regular Expressions), try/catch 오류 처리, strict 모드 등의 기능이 추가되었다.
• 자바스크립트가 브라우저 내 상호작용의 핵심 기술로 자리 잡게 되는 중요한 기점이 된다.
```

2005년 - AJAX와 웹 2.0

```
• AJAX(Asynchronous JavaScript and XML) 기술이 웹에 도입되면서, 자바스크립트는 비동기적으로 서버와 데이터를 주고받을 수 있는 중요한 도구로 부상한다.
• 이를 통해 Google Maps와 같은 동적인 웹 애플리케이션이 가능해졌고, 웹 2.0 시대가 열린다.
• 자바스크립트는 이제 단순한 스크립트 언어에서 강력한 애플리케이션 개발 도구로 발전하게 된다.
```

2009년 - ECMAScript 5 (ES5)

```
• ECMAScript 5는 JSON 지원, strict 모드, 객체 및 배열 처리 개선 등 중요한 기능을 포함하여 자바스크립트의 안정성과 확장성을 크게 향상시킨다.
• 이 버전은 매우 오랜 기간 동안 표준으로 자리 잡았으며, 현재 많은 웹 브라우저에서 지원된다.
```

2009년 - Node.js의 등장

```
• 라이언 달(Ryan Dahl)이 Node.js를 출시하며 자바스크립트를 서버 측에서도 사용할 수 있게 된다.
• 이를 통해 자바스크립트는 클라이언트뿐만 아니라 서버 측 개발에서도 중요한 언어가 되었으며, 풀 스택 자바스크립트 개발의 기틀을 마련했다.
```

2015년 - ECMAScript 6 (ES6/ES2015)

```
• 자바스크립트 역사상 가장 중요한 업데이트 중 하나인 ES6이 도입되었다.
• let, const 키워드, 화살표 함수, 클래스 문법, 모듈 시스템, Promise, 템플릿 리터럴 등 혁신적인 기능들이 추가되었다.
• 이 업데이트는 자바스크립트의 사용성을 크게 향상시키고, 대규모 애플리케이션 개발에 적합한 언어로 진화시켰다.
```

ES5와 ES6 사이의 공백기간이 길어 업데이트 내용이 가장 많기에 ES6가 현재까지도 표준을 대표한다.

<br>
<br>

### 왜 여전히 Babel과 같은 트랜스컴파일러가 필요한가?

JavaScript는 웹 개발의 핵심언어로 브라우저 환경에서 필수적인 역할을 수행한다. ES6가 도입된 이후 많은 기능적 발전을 이루었지만 최신 문법을 모든 브라우저에서 즉시 지원하는것은 아니다.

이 부분에서 트랜스컴파일러(Babel)를 사용하여 코드를 구형 브라우저에서도 호환 되도록 변환하는 작업이 필요하게 되었다.

e.g.

```
let, const 같은 ES6 변수 선언을 ES5의 var로 변환.
화살표 함수 () => {}를 기존의 function() 표현식으로 변환.
```

<br>
<br>

### HTML Script 태그의 async와 defer 속성 – 웹 성능 최적화를 위한 선택

JavaScript 파일을 HTML 문서에 포함할 때, 웹 성능에 영향을 미치는 중요한 요소 중 하나가 스크립트 로딩 방식 <br>
script 태그는 문서의 body 끝부분에 위치하는 것이 관례였지만 `async`와 `defer` 속성을 사용하면 더 유연하고 성능 좋은 웹 페이지를 만들 수 있다.

<br>

#### 기본 script 태그 동작

기본적으로 script 태그는 HTML 문서가 위에서 아래로 파싱되는 동안 만나면 그 즉시 파싱을 중단하고 스크립트를 로드 및 실행한다. 즉 JavaScript 파일을 불러오는 동안 HTML 파싱이 멈추며 스크립트가 로드되고 실행될 때까지 기다리게 됩니다.

- 단점: 스크립트가 많거나 용량이 크면, 페이지가 늦게 렌더링될 수 있다.

<br>

#### async 속성

async 속성은 스크립트의 다운로드와 실행을 병렬로 처리하는 방법<br>HTML 파싱이 진행되는 동안에도 스크립트를 비동기적으로 다운로드할 수 있다. 하지만 다운로드가 완료되는 즉시 실행되기 때문에, 스크립트 실행 순서가 보장되지 않는다. 이 방식은 독립적인 스크립트나 다른 스크립트와의 순서가 중요하지 않은 경우에 적합

- 광고, 분석 툴, 또는 추가적인 추적 코드와 같이 다른 코드와 의존 관계가 없는 스크립트에 적합
- 페이지 로딩과 동시에 스크립트를 빠르게 실행하고 싶은 경우에 유용

e.g.

```html
<script src="example.js" async></script>
```

<br>

#### defer 속성

defer 속성은 스크립트를 병렬로 다운로드하면서도, HTML 문서가 완전히 파싱된 후에 순차적으로 스크립트를 실행하는 방법<br>스크립트 실행 순서가 보장되기 때문에, 의존 관계가 있는 스크립트들에 매우 적합

- DOM이 준비된 후에 실행되어야 하는 UI 관련 스크립트나 의존성이 있는 스크립트에 적합합니다.
- 라이브러리나 프레임워크처럼, 다른 스크립트와 순서대로 실행되어야 할 때 유용합니다.

e.g.

```html
<script src="example.js" defer></script>
```

<br>

#### script 태그를 body 끝에 위치시키는 이유

async와 defer 속성이 도입되기 전에는 script 태그를 body 끝에 배치하는 것이 관례였다. 그 이유는 HTML 파싱을 중단하지 않기 위함이었다.<br>script 태그를 body 끝에 배치하면 모든 HTML 파싱이 완료된 후에 스크립트가 실행되므로 페이지 로딩이 더 빨라지는 효과가 있었습니다.

하지만 이 방법은 여전히 스크립트가 다운로드될 때까지 기다려야 하므로 성능 최적화 측면에서는 완전하지 않았다. async와 defer 속성은 이 문제를 해결하며, 다운로드와 실행을 효율적으로 처리한다.

<br>

#### 그럼 무엇을 사용해야 될까?

defer 속성은 현대적인 방법으로 대부분의 상황에서 더 나은 선택<br> HTML 파싱이 끝난 후에 스크립트를 실행하기 때문에 성능 최적화에 도움이 되며 실행 순서도 보장된다. 일반적으로 defer 속성을 사용하는 것이 페이지 로딩 성능을 최적화하는데 가장 좋은 선택

<br>
<br>

### 자바스크립트 vs 타입스크립트 : 동적 언어와 정적 언어의

#### 자바스크립트는 동적 타입(dynamic typing)언어

변수의 데이터 타입이 런타임에 결정된다는 의미다. 코드를 실행하기 전까지 변수의 타입을 정확히 알 수 없다.<br>이런 특성 덕분에 자바스크립트는 매우 유연하지만 런타임에 예기치 않은 오류가 발생하는 위험이 있다

1. 변수에 어떤 타입의 값이든 할당할 수 있으며, 할당된 값에 따라 타입이 결정된다.
2. 런타임에서만 타입 오류를 확인할 수 있다.

```javascript
let value = "Hello" // value는 문자열
value = 42 // 이제 숫자로 변경됨
console.log(value) // 42 출력
```

<br>

#### 타입스크립트는 정적 타입(static typing) 언어

변수를 정의할 때 타입을 명시할 수 있다. 정적 타입이란 변수의 데이터 타입을 컴파일 타임에 결정하는 것을 의미한다.<br> 이를 통해 타입 오류를 코드 작성 시 미리 발견할 수 있으며 코드의 안정성이 높아진다.

1. 변수와 함수의 타입을 명시적으로 지정할 수 있다.
2. 컴파일 시 타입 검사를 통해 오류를 미리 찾아낼 수 있다.

```typescript
let value: string = "Hello" // value는 문자열로 고정됨
value = 42 // 오류: 'number' 타입을 'string' 타입에 할당할 수 없음
```

#### 왜 타입스크립트를 사용해야 할까?

타입스크립트는 자바스크립트의 단점을 보완하여 대규모 프로젝트나 협업이 중요한 프로젝트에서 더욱 효율적이다. 정적 타입 검사는 개발자가 작성한 코드가 런타임에서 안전하게 실행될 수 있음을 보장하며, 오류 발생 가능성을 줄인다.

<br>
<br>

### 타입스크립트의 타입 지정 방식

#### 타입 주석 vs 타입 추론

```typescript
// 타입 주석
let age: number = 25
```

타입을 명시적으로 적어주어 직관적이며 코드를 읽기 쉽게 만든다.<br>타입을 명확히 알 수 있으며 유지보수할 떄 유리할 수 있다

- 장점: 코드의 명확성과 가독성이 높다
- 단점: 타입을 수동으로 적는 데서 오는 중복과 복잡성이 늘어날 수 있다

<br>

```typescript
// 타입 추론
let age = 25 // TypeScript는 자동으로 age가 number 타입임을 추론함
```

타입을 추론함으로써 간결한 코드 작성이 가능하며 주석을 일일이 추가할 필요가 없이 빠르게 코딩이 가능하다.

- 장점: 간결한 코드 작성, 코드가 단순해진다.
- 단점: 복잡한 코드에서 추론된 타입을 이해하기 어렵거나 실수할 가능성이 있다.

<br>

#### 타입 주석과 타입 추론의 성능 차이는 없다

타입을 명시하거나 추론하더라도 컴파일 이후의 결과물(JS파일)은 동일하다.<br>
정의 방식에 성능 차이는 없으므로 팀 스타일에 따라 유연하게 사용하자

<br>
<br>

### 타입별칭(Type Aliases) vs 인터페이스(Interface)

#### 타입별칭 (type)

```typescript
type User = {
  name: string
  age: number
}
```

타입별칭은 타입을 정의하는 단순한 방법으로, 복잡한 타입을 더 읽기 쉽게 만들거나 재사용할 수 있게 해준다. 문법적으로 타입별칭은 중복 정의가 불가능하며 동일한 타입이 여러 번 선언되면 에러가 발생한다. 이는 협업 시 중복된 타입 이름을 방지하고, 유지보수를 쉽게 만들어 준다.

- 장점

  타입 중복을 방지하여 에러 발생 확률을 줄일 수 있다.<br>
  간결한 코드 작성과 유지보수가 용이하다.

- 단점

  타입 병합이 불가하므로 동일 이름의 타입을 확장하거나 여러 곳에서 재정의하기 어렵다.

<br>

#### 인터페이스 (interface)

인터페이스는 객체의 구조를 정의할 수 있으며 타입과 유사하게 동작하지만 타입 병합이 가능하다. 같은 이름의 인터페이스를 여러 번 정의하면 자동으로 병합되며, 여러 곳에서 사용된 정의가 하나로 합쳐질 수 있다. 하지만 프로젝트가 커지고 복잡해지면 중복된 인터페이스 이름을 찾기 어렵고, 에러를 발생시킬 수 있다.

```typescript
interface User {
  name: string
  age: number
}
```

- 장점

  타입 병합이 가능해 확장이 용이하다.<br>
  코드의 유연성이 증가한다.

- 단점

  같은 이름의 인터페이스가 여러 번 병합될 경우, 코드의 복잡성이 증가할 수 있다.

<br>

#### 사용 추세와 편의성 차이?

타입스크립트의 type과 interface는 거의 모든 기능을 공유하며, 인터페이스로 할 수 있는 기능은 타입별칭으로도 구현할 수 있다.다만 실수나 중복을 줄이기 위해 타입별칭을 선호하는 경우도 있다.

타입별칭(type)은 코드에서 마우스 hover 시 타입 정보를 툴팁에서 바로 확인할 수 있지만 인터페이스(interface)는 툴팁에서 타입 정보를 바로 볼 수 없다. 이러한 차이점으로 인해 작업할 때 타입별칭을 사용하는 것이 더 직관적이라 생각할 수 있겠다.

<br>
<br>

### Vite와 트랜스컴파일러: 타입스크립트와 현대 웹 개발

#### 타입스크립트와 브라우저 왜 트랜스컴파일이 필요한가?

타입스크립트(TypeScript)는 정적 타입 시스템을 제공하며 개발 과정에서 코드의 안전성을 높여 준다. 그러나 타입스크립트는 브라우저에서 직접 실행되지 않는다. 현재 대부분의 웹 브라우저는 ES6 이하의 ECMAScript(특히 ES5) 문법을 지원하므로, 타입스크립트로 작성된 코드는 브라우저에서 실행 가능하도록 트랜스컴파일되어야 한다.

브라우저에서의 타입스크립트 실행 과정

```
1.	타입스크립트 코드 작성
2.	트랜스컴파일러를 통해 코드가 ES5(또는 ES6)로 변환
3.	변환된 자바스크립트 코드가 브라우저에서 실행

트랜스컴파일러는 타입스크립트가 브라우저에서 제대로 동작할 수 있도록 해주는 필수 도구
```

<br>

#### Vite와 트랜스컴파일러

Vite는 빠르고 현대적인 웹 개발 빌드 도구다. Vite는 트랜스컴파일러로 Babel과 SWC 중 하나를 사용할 수 있으며, 빠른 개발 환경을 제공하는 것이 장점이다.<br> 특히 ES 모듈 기반으로 동작하여 개발 단계에서 모듈 간의 의존성을 효율적으로 처리하고, 전체 애플리케이션을 다시 빌드하지 않고 변경된 부분만 빠르게 업데이트한다.

Vite의 주요 특징

```
빠른 초기 빌드: 소규모의 ES 모듈 기반으로 빠른 개발 환경 제공
빠른 HMR(Hot Module Replacement): 코드가 변경될 때, 전체 페이지가 아닌 변경된 모듈만 새로고침
트랜스컴파일러 사용: 타입스크립트를 ES5/ES6로 변환해주는 역할
```

<br>

#### 트랜스컴파일러: Babel vs SWC

Babel: 가장 널리 쓰이는 트랜스컴파일러

Babel은 오랫동안 자바스크립트 생태계에서 표준 트랜스컴파일러로 자리 잡았다. 타입스크립트를 포함해 최신 자바스크립트 문법을 호환성 있는 ES5로 변환하는 데 매우 유용하다. 대부분의 개발 도구에서 기본적으로 사용되고 있으며, 다양한 플러그인과 설정을 통해 확장성과 유연성을 제공한다.

- 장점

  커뮤니티 지원이 풍부하고 널리 사용됨<br>
  다양한 플러그인과 확장 가능성

- 단점

  최신 대안에 비해 성능이 다소 떨어짐 (빌드 속도)

<br>

SWC: 차세대 트랜스컴파일러

SWC(Speedy Web Compiler)는 한국인 1인 개발자가 만들었으며, 속도에 최적화된 트랜스컴파일러이다. Babel보다 약 25% 빠른 속도를 자랑하며, 특히 대규모 프로젝트에서 빌드 시간을 크게 단축할 수 있다. SWC는 성능이 중요한 프로젝트에서 Babel의 대안으로 주목받고 있으며, Vercel에서 SWC를 공식 지원하면서 더욱 인기를 끌고 있다.

- 장점

  빠른 속도: Babel에 비해 빌드 성능이 약 25% 더 빠름
  최적화된 성능: 대규모 프로젝트에서 성능 향상 체감

- 단점

  커뮤니티와 플러그인 생태계는 아직 Babel만큼 강력하지 않음

<br>

강동윤 개발자 님 (main developer of the swc project)<br>
https://github.com/kdy1

<br>

#### 트랜스컴파일러 성능을 직접 체감하기는 어려운 이유

트랜스컴파일러의 성능 차이는 개발 환경에서 가장 많이 나타난다. 개발단계에서는 소스 코드가 자주 변경되고 빠른 빌드와 HMR이 필요하다. SWC는 이러한 개발자 경험을 개선하는 데 큰 도움이 되지만, 프로덕션(최종 빌드) 단계에서 체감하기는 다소 어렵다. 프로덕션에서는 빌드 속도가 중요한데, 일반적인 규모의 프로젝트라면 Babel과 SWC의 차이가 크게 느껴지지 않을 수 있다.

따라서, 대규모 프로젝트나 빌드 성능 최적화가 중요한 환경에서는 SWC가 유리할 수 있지만, 소규모 또는 중간 규모의 프로젝트에서는 그 차이가 크지 않을 수 있다.

<br>
<br>
<br>

——————————————————————————<br>
본 후기는 본 후기는 [유데미x스나이퍼팩토리] 프로젝트 캠프 : Next.js 3기 과정(B-log) 리뷰로 작성 되었습니다.<br>

#유데미 #udemy #웅진씽크빅 #스나이퍼팩토리 #인사이드아웃 #미래내일일경험 #프로젝트캠프 #부트캠프 #React #리액트프로젝트 #프론트엔드개발자양성과정 #개발자교육과정
